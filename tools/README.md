# Developer and Debugging Tools

This directory contains various standalone Python scripts to assist with development, debugging, and direct interaction with the project's external dependencies (Git, Neo4j, etc.).

Besides the given command line usages below, you can always use --help to see the full CLI options.

## Table of Contents
- [`get_git_changed_files.py`](#get_git_changed_filespy)
- [`run_cyper_file.py`](#run_cyper_filepy)
- [`unique_yaml_lines_with_markers.py`](#unique_yaml_lines_with_markerspy)
- [`c_ast_to_dot.py`](#c_ast_to_dotpy)
- [`check_if_c_header.py`](#check_if_c_headerpy)
- [`find_impacted_sources.py`](#find_impacted_sourcespy)

---

## `get_git_changed_files.py`

This script is a command-line interface for the `GitManager` library. It provides a quick way to see the lists of added, modified, and deleted source files between any two Git commits.

### Usage
```sh
python get_git_changed_files.py <repo_path> <old_commit> <new_commit>
```

### Example
```sh
# Show changes between two commit hashes
python tools/get_git_changed_files.py . 7a4a2b1 2b8e6a5

# Show changes between a tag and the current HEAD
python tools/get_git_changed_files.py . v1.0 HEAD
```

---

## `run_cyper_file.py`

This utility executes a `.cql` file containing one or more Cypher queries against the Neo4j database. It was created to run the batch Cypher files generated by `clangd_call_graph_builder.py` when it is run without the `--ingest` flag. It also supports simple parameterized queries where parameters are defined in a JSON object in a comment on the line immediately following the query.

### Usage
```sh
python run_cyper_file.py <path_to_cql_file>
```

---

## `unique_yaml_lines_with_markers.py`

This is a simple parsing utility for debugging the raw `clangd` index YAML files. It reads a large YAML file that contains many documents separated by `---` and `...` markers and prints all of the unique lines found across all documents. This is useful for discovering the different kinds of data fields and structures present in the index.

### Usage
```sh
python unique_yaml_lines_with_markers.py <path_to_index.yaml>
```

---

## `c_ast_to_dot.py`

This script is the main utility for visualizing the Abstract Syntax Tree (AST) of a C source file using `tree-sitter`.

### Prerequisites

-   Python 3.6+
-   **Graphviz**: Required for generating image files from DOT graphs.
-   **Python Packages**: `pip install tree-sitter tree-sitter-c tree-sitter-cpp`

### Usage

The script takes a C source file as input and generates three output files by default:
1.  A `.ast` file with a textual tree structure.
2.  A `.dot` file in Graphviz format.
3.  An image file (e.g., `.png`) rendered from the `.dot` file.

```sh
python c_ast_to_dot.py [OPTIONS] <input_file>
```

**Options:**

-   `-o, --output <file>`: Specify the name for the output DOT file.
-   `-f, --format <format>`: Set the output image format (e.g., `png`, `svg`).
-   `--no-image`: Suppress the generation of the image file.

---

## `check_if_c_header.py`

This script is a helper utility designed to distinguish between C and C++ header files. It is used by other tools like `c_ast_to_dot.py` to decide which parser (C or C++) to use for a given `.h` file.

It uses two main heuristics:
1.  **Sibling File Check**: It checks if there are any files with common C++ extensions (e.g., `.cpp`, `.cxx`) in the same directory.
2.  **Content Analysis**: It parses the header file using `tree-sitter-cpp` and looks for AST nodes that correspond to C++-only language features (e.g., `class`, `template`, `namespace`).

### Usage

```sh
python check_if_c_header.py <path_to_header.h>
```

---

## `find_impacted_sources.py`

This script is a powerful dependency analysis tool that finds all source files (`.c`, `.cpp`, etc.) that are transitively impacted by a change in a given header file. It was originally created to debug and prototype the dependency analysis logic that is now integrated into the main `GraphUpdater` pipeline.

It provides a compiler-accurate analysis by leveraging `clang`'s parsing engine.

### How It Works

1.  It parses every source file specified in the `compile_commands.json` database using `clang.cindex`.
2.  As it parses, it extracts all `#include` directives for each translation unit.
3.  It uses this data to build a complete, in-memory **reverse include graph** (mapping included headers to the files that include them).
4.  Finally, it performs a traversal backwards from the user-specified header to find every source file that depends on it, directly or indirectly.

### Prerequisites

-   `clang` must be installed and available in the system's `PATH`.
-   A `compile_commands.json` file for the project must be available.

### Usage
```sh
python tools/find_impacted_sources.py <path_to_compile_commands.json> <path_to_changed_header.h>
```
