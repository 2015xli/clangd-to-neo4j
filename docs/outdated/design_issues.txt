The overall "mini-index" strategy has Incorrect Handling of Older clangd Index Formats

  The script will fail to correctly update the call graph when using a clangd index file that lacks the Container field
  (i.e., from clangd versions before 21.x). This is due to two related flaws:


   1. Incomplete "Mini-Index" Creation: In Phase 3 (_build_mini_index), the logic to find 1-hop neighbors (callers and callees)
      of the changed symbols relies exclusively on the ref.container_id field. If this field doesn't exist, no neighbors are
      found. The "mini-index" will only contain the symbols from the changed files, but not the symbols from unchanged files
      that call them or are called by them.


   2. Incomplete Span Information for Call Graph Rebuilding: In Phase 4 (_rerun_ingestion_pipeline), when the script detects it needs to use ClangdCallGraphExtractorWithoutContainer, it initializes a FunctionSpanProvider with only the list of changed
files. The extractor needs function spans for all files in the mini-index (including the neighbors from unchanged files) to spatially resolve the call graph. Since it only receives spans for the changed files, it cannot create the :CALLS relationships between the updated code and any existing, unchanged code.


  Impact: When running an incremental update on a project indexed with an older version of clangd, the updated functions
  will appear isolated in the graph, with their incoming and outgoing calls to the rest of the codebase missing.

  So far it is ok since we only support Clang 21.x currently. And will decide if we need support earlier versions that have no container field. 


Bigger issue:

The mini-index has all the symbols related to the changed files. There is a situation that, when a header file is changed, the source .c files that include it may not be changed. Their symbols may not be included in the mini-index.

  The symbols from the unchanged .c file would not be included in the mini-index,unless they have a direct call relationship with a symbol in the changed header.

  Here's the breakdown of why:

   1. Seed Symbols: The process starts with "seed symbols" from the files that were textually modified. In this case,
      that would be the symbols defined within the changed header file.
   2. Neighbor Expansion: The documentation states that the mini-index is expanded by finding 1-hop neighbors, which are
       defined as callers and callees.
   3. The Gap: The logic for finding neighbors is based on function calls (:CALLS relationships), not on type usage or
      macro expansion. If the unchanged .c file includes the header and uses a struct or typedef from it, but never
      calls a function defined in that header (or is not called by one), the 1-hop traversal will not discover the
      symbols in the .c file.

  The current mini-index creation logic is insufficient. A change to a widely used struct, enum, or macro in a header file would not cause the symbols from including source files to be added to the mini-index.  Macro redefined function names and bodies are not included either.

  Consequently, the graph would not be correctly updated to reflect the semantic changes that cascaded from the header into those source files. The system would fail to re-summarize or re-analyze the functions in the .c file, because their symbols were never added to the processing scope of the mini-index.


It looks good. I have another thought. The current graph for function node does not have property of     
function span (definition_location), but a property location for name (should be name_location)? I am    
thinking to create span provider earlier before ingesting function node to provide definition_location   
for the function node. In this way, we also ensure that we have span provider created always. In this    
way, we don't need create another span provider in rag (in case it has not created yet), since it is     
always created. This has a good side effect that, after call-graph is built, we can delete symbol parser,
since it is the last module that need the parser. Actually RAG generation will not need Span provider at all, since it can retrieve the span from the node directly.
